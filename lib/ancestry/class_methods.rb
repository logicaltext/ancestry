module Ancestry
  module ClassMethods
    # Returns the tree node given either the node itself or the node's id.
    #
    # @param  [Object, Integer] arg The node or id of the node to return.
    # @return [Object] The node.
    #
    def to_node(arg)
      arg.is_a?(self.base_class) ? arg : find(arg)
    end 
    
		# Returns a dynamic scope based on the supplied relative depth options.
    #
    # @param  [Hash] depth_options The depth options.
    # @option depth_options [Integer] :key The relative depth of the node in
    #         question, where +:key+ is one of the keys defined in
    #         {Ancestry::DEPTH_SCOPES}.
    # @param  [Integer] depth The depth of the node in question.
    # @return [ActiveRecord::NamedScope::Scope, self] The +NamedScope+ or
    #         +self+ if +depth_options+ is an empty hash.
    # @raise  [Ancestry::AncestryException] If supplied key of depth_options
    #         hash is not included in {Ancestry::DEPTH_SCOPES}.
    #
    def scope_depth(depth_options, depth)
      depth_options.inject(self.base_class) do |klass, option|
        scope_name, relative_depth = option
        if Ancestry::DEPTH_SCOPES.keys.include?(scope_name)
          klass.send(scope_name, depth + relative_depth)
        else
          msg = "Unknown depth option: #{scope_name}."
          raise Ancestry::AncestryException.new(msg)
        end
      end
    end

    # Sets the orphan strategy for the class.
    #
    # @param  [Symbol] orphan_strategy A symbol defined in
    #         {Ancestry::ORPHAN_STRATEGIES}.
    # @return [Symbol] The supplied orphan strategy.
    # @raise  [Ancestry::AncestryException] If supplied +orphan_strategy+ is
    #         not included in {Ancestry::ORPHAN_STRATEGIES}.
    #
    def orphan_strategy=(orphan_strategy)
      if Ancestry::ORPHAN_STRATEGIES.include?(orphan_strategy)
        class_variable_set :@@orphan_strategy, orphan_strategy
      else
        raise Ancestry::AncestryException.new(invalid_orphan_strategy_message)
      end
    end

    # Returns a subtree in the form of nested hashes. The hashes will be
    # ordered if using Ruby 1.9+ and an +:order+ paramater is supplied.
    #
    # @param  [Hash] options The options to use for creating the representation
    #                of the specified subtree.
    # @option opts [Symbol] :order The order in which to arrange the
    #              collection of nodes.
    # @return [Hash<Hash>] A hash of hashes.
    #
    def arrange(opts = {})
      scope = arrange_scope_based_on_options(opts)
      scope.all.inject({}) do |arranged_nodes, node|
        insertion_point = find_insertion_point_for_node(arranged_nodes, node)
        insertion_point[node] = {}
        arranged_nodes
      end
    end

    # Checks the integrity of all nodes.
    #
    # @raise  [Ancestry::AncestryException,
    #          Ancestry::AncestryIntegrityException]
    # @return nil If all nodes have maintained integrity.
    #
    def check_ancestry_integrity!
      parents = {}
      self.base_class.all.each do |node|

        raise_error_for_invalid_ancestry_column(node)
        raise_error_for_any_nonexistent_ancestors(node)

        node.path_ids.zip([nil] + node.path_ids).each do |node_id, parent_id|
          parents[node_id] = parent_id unless parents.has_key?(node_id)
          unless parents[node_id] == parent_id
            msg  = "Conflicting parent id in node #{node.id}:"
            msg += " #{parent_id || 'nil'} for node #{node_id},"
            msg += " expecting #{parents[node_id] || 'nil'}"
            raise Ancestry::AncestryIntegrityException.new(msg)
          end
        end

      end
    end

    # Restores the integrity of all nodes.
    #
    # @return nil.
    #
    def restore_ancestry_integrity!
      parents = {}
      self.base_class.all.each do |node|
        set_ancestry_attribute_to_nil_if_node_is_invalid(node)

        parents[node.id] = node.parent_id if exists? node.parent_id

        # Reset parent id in hash to nil if it introduces a cycle.
        parent = parents[node.id]
        until parent.nil? || parent == node.id
          parent = parents[parent]
        end
        parents[node.id] = nil if parent == node.id 
      end

      self.base_class.all.each do |node|
        # Rebuild ancestry from parents hash.
        ancestry, parent = nil, parents[node.id]
        until parent.nil?
          ancestry = ancestry.nil? ? parent : "#{parent}/#{ancestry}"
          parent   = parents[parent]
        end
        node.without_ancestry_callbacks do
          node.update_attributes node.ancestry_column => ancestry
        end
      end
    end

    # Builds ancestry from parent id's for migration purposes.
    #
    # @param  [Integer] parent_id The parent id for updating a specific node.
    # @param  [String] ancestry The value of the ancestry column for updating
    #         a specific node.
    # @return [Array] The array of nodes generated by iterating over
    #         +self.base_class.where(:parent_id => parent_id)+.
    #
    def build_ancestry_from_parent_ids!(parent_id = nil, ancestry = nil)
      self.base_class.where(:parent_id => parent_id).each do |node|
        node.without_ancestry_callbacks do
          node.update_attribute ancestry_column, ancestry
        end
        ancestry = ancestry.nil? ? "#{node.id}" : "#{ancestry}/#{node.id}"
        build_ancestry_from_parent_ids!(node.id, ancestry)
      end
    end

    # Rebuild the depth cache in case it is corrupted or if depth caching has
    # just been turned on.
    #
    # @raise  [Ancestry::AncestryException] If there is no depth caching for
    #         this model.
    # @return [Array] The array of nodes generated by +self.base_class.all+.
    #
    def rebuild_depth_cache!
      unless respond_to?(:depth_cache_column)
        msg = "Cannot rebuild depth cache for model without depth caching."
        raise Ancestry::AncestryException.new(msg)
      end
      self.base_class.all.each do |node|
        node.update_attribute depth_cache_column, node.depth
      end
    end


    private

    def invalid_orphan_strategy_message
      allowed = Ancestry::ORPHAN_STRATEGIES.map { |x| ":#{x.to_s}" }
      allowed[allowed.size-1] = "and #{allowed.last}"
      msg = "Invalid orphan strategy, valid ones are #{allowed.join(', ')}"
    end

    def arrange_scope_based_on_options(opts)
      if opts[:order].nil?
        scope = self.base_class.ordered_by_ancestry
      else
        scope = self.base_class.ordered_by_ancestry_and(opts.delete(:order))
      end
    end

    def find_insertion_point_for_node(node_hash, node)
      node.ancestor_ids.inject(node_hash) do |insertion_point, ancestor_id|
        insertion_point.each do |parent, children|
          # Change the insertion point to children if node is a descendant
          # of this parent
          insertion_point = children if ancestor_id == parent.id
        end
        insertion_point
      end
    end

    def raise_error_for_invalid_ancestry_column(node)
      if !node.valid? and node.errors[node.class.ancestry_column].any?
        msg  = "Invalid format for ancestry column of node #{node.id}:"
        msg += " #{node.read_attribute node.ancestry_column}."
        raise Ancestry::AncestryIntegrityException.new(msg)
      end
    end

    def raise_error_for_any_nonexistent_ancestors(node)
      node.ancestor_ids.each do |ancestor_id|
        unless exists?(ancestor_id)
          msg  = "Reference to non-existent node in node #{node.id}:"
          msg += " #{ancestor_id}."
          raise Ancestry::AncestryIntegrityException.new(msg)
        end
      end
    end

    def set_ancestry_attribute_to_nil_if_node_is_invalid(node)
      if node.errors[node.class.ancestry_column].any?
        node.without_ancestry_callbacks do
          node.update_attributes :ancestry => nil
        end
      end
    end

  end
end